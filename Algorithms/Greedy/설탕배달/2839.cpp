#include <iostream>

using namespace std;
// 이 문제는 순차적으로 5로 나눠주고 남은값을 3으로 나누는 방법이 아니다.
// 9의 경우 5로 5로 한번나눠지고 4가남는데 3으로 떨어지지 않아 -1을 반환하게 된다.
// 그러므로, 5와 3의 비율을 잘 조절해야한다.
// 5로만 나누어 떨어지는 경우, 3으로만 나누어 떨어지는 경우, 두가지를 사용하는 경우를 모두 고려해보고
// 3가지를 해도 안되면 -1이 되게 해야한다.

// => 어떻게 해야할까?
// 0부터 작은수의 배수를 차례대로 뺀 후 남은 수가 큰수로 나누어 떨어지는 지 확인하다.
// 이 떄 작은수가 입력값을 초과 할때 까지 나누어 떨어지지 않는다면, -1을 반환한다.

int main()
{

    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int bag[2] = {3, 5};
    int n;
    cin >> n;

    int temp = n; // 0보다 작으면 for문안에 안들어가서 초기값 넣어줘야함.
    int i;

    for (i = 0; temp >= 0; i++)
    {
        temp = n - bag[0] * i; // 0 3 6 9 를 뺀 값을 넣어줌
        // cout << " 중간 " << i << " " << temp << "\n";

        if (temp == 0 || temp % bag[1] == 0) // 3그램 봉투로만 이루어진 설탕이어서 값이 0이 되거나, 뺀 값이 5의 배수로 나누어 떨어지는지 확인
        {
            cout << i + temp / bag[1] << "\n"; // 3 개수와 5 개수를 더한 값을 출력
            return 0;                          // break아니고 return
        }
    }
    // cout << " 최종 " << i << " " << temp << "\n";
    cout << -1 << "\n"; // 다 돌았는데 나누어 떨어지지 않았다면 -1

    return 0;
}
// 바구니 개수가 늘어나면 어떤 방식으로 할 수 있을지 생각해 볼 것!